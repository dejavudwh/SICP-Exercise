# **SICP CONCLUSION**

> 让我们举起杯，祝福那些将他们的思想镶嵌在重重括号之间的Lisp程序员 ！

> 祝我能够突破层层代码，找到住在里计算机的神灵！

## **<font color = "green">目录</font>**
##### 1. 构造过程抽象
##### 2. 构造数据抽象
##### 3. 模块化、对象和状态
##### 4. 元语言抽象
##### 5. 寄存器机器里的计算

## **<font color = "red">Chapter 1</font>**
- 构造过程对象

#### 程序设计的基本元素

> 强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，还应该提供一种框架，使我们能够自己有关计算过程的思想

- 基本表达形式 (*过程 or 数据?*)
- 组合的方法
- 抽象的方法


###### 1. 表达式
###### 2. 命名和环境（变量）
或许给变量命名就是语言中最小的抽象？
> 构造一个复杂的程序，就是为了去一步步地创建出越来越复杂的计算性对象
###### 3. 组合式的求值
在*环境*中，先求解子表达式（一种递归
###### 4. 复合过程
更强大的抽象方法：***定义过程***
###### 5. 代换模型
一种简单的计算模型，简单的说明了实参代替形参
> 考虑科学研究或者工程中的现象，一般从最简单的模型开始，随着更细致的考虑问题，应该完善模型更换模型

应用序和正则序：取决于解释器的实现，更深层时应考虑两者的优缺点
###### 6.条件表达式和谓词

### **7.实例：牛顿法求平方根**
> 函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事之间的普遍性差异的一个具体反映
看一下书里怎么教我们用牛顿法求平方根

1. 描述事情的解决思路：给出猜测，不断改进这个猜测，直到觉得满足
2. 直接描述方法和各个部件，不管具体实现，抽象思想

```
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
    guess
    (sqrt-iter (improve guess x)
                              x)))
```
3. 实现各个部件的细节 good-enough? improve

###### 8. 过程作为黑箱抽象

- 将平方根问题自然的分解为若干个子问题
  - 猜测足够好?
  - 怎么改进？
- 过程抽象：分解过程，使之成为了可以独立工作的模块
- 隐藏一些细节，作为黑箱给其他程序员使用

*一些细节*
- 局部名、约束变量、作用域

 一样的为了更高度的模块化，

 - 内部定义和块结构

  依旧是为了更高的模块化，屏蔽我内部的所有名称，更高度的黑盒
